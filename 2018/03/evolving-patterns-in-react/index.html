<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>Evolving Patterns in React - React 中的模式演化 | TryCatch</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="react,翻译,js" />
    
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.0.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-92905809-1', 'auto');
ga('send', 'pageview');

</script>
    
    
        <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?409648b1638886ada0891d05cc80dc19";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    
    
        <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
    
    

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>

<body>
  <div id="page-percent"><div></div></div>
  <header id="header">
  <div id="header-nav" class="nav-container">
    <ul>
      
          <li class="main-nav-list-item" >
            <a class="main-nav-list-link" href="/">主页</a>
          </li>
      
          <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Uncategory/">Uncategory</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/css/">css</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/html/">html</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/js/">js</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/翻译/">翻译</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/转载/">转载</a></li></ul>
        
    </ul>
  </div>
</header>
  <div class="main-body container-inner">
    <div class="main-body-inner">
      <section id="main">
        <div class="main-body-content">
          <article id="post-evolving-patterns-in-react" class="article article-single article-type-post" itemscope itemprop="blogPost">
    
    
        <h1 class="article-title" itemprop="name">
        Evolving Patterns in React - React 中的模式演化
        </h1>
    

    <header class="article-header" >
        <div class="article-author-avatar">
            <img src="/images/avatar.png" alt="Author's avatar">
        </div>
        <div class="article-subtitle">
            <div class="article-author">
                tcatche
            </div>
            <div class="article-meta">
                <a href="/2018/03/evolving-patterns-in-react/" class="article-date">
    <i class="icon fa fa-calendar"></i>
    2018-03-07
</a>
                
    <span class="word-count">
      <i class="icon fa fa-file-text"></i>
      字数: 3,402 
    </span>
    <span class="word-count">
      <i class="icon fa fa-clock-o"></i>
      阅读时长: 17mins 
    </span>

            </div>
            <div class="article-dir">
                
    <div class="article-category">
    <i class="icon fa fa-list-ul"></i>
    <a class="article-category-link" href="/categories/翻译/">翻译</a>
    </div>

                
    <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

            </div>
        </div>
    </header>
    <div class="article-inner">
        
        <div class="article-entry" itemprop="articleBody">
            <p>翻译自：<a href="https://medium.freecodecamp.org/evolving-patterns-in-react-116140e5fe8f" target="_blank" rel="external">Evolving Patterns in React</a></p>
<p>Let’s take a closer look at some of the patterns that are emerging in the React ecosystem. These patterns improve readability, code clarity, and push your code towards composition and reusability.</p>
<p>让我们仔细看看出现在 React 生态系统中的一些模式。这些模式可提高你的代码的可读性和清晰度，更加的可组合性和可复用性。</p>
<p>I started working with <a href="https://reactjs.org/" target="_blank" rel="external"><strong>React</strong></a> roughly about 3 years ago. At that time, there were no established practices from which to learn in order to leverage its capabilities.</p>
<p>大约3年前我开始使用 React 工作，那个时候，还没有一个成熟的可以参考的模式。</p>
<p>It took about 2 years for the community to settle around a few ideas. We shifted from <code>React.createClass</code> to the ES6 <code>class</code> and pure functional components. We dropped mixins and <a href="https://reactjs.org/blog/2016/04/07/react-v15.html" target="_blank" rel="external">we simplified our APIs</a>.</p>
<p>社区花了大约2年的时间才解决一些想法。我们从 <code>React.createClass</code> 转移到 ES6 类和纯函数组件。我们放弃了mixin，并<a href="https://reactjs.org/blog/2016/04/07/react-v15.html" target="_blank" rel="external">简化了 API</a></p>
<p>Now as the community is larger than ever, we’re starting to see a couple of nice patterns <strong>evolving</strong>.</p>
<p>现在，社区比以往更大，我们开始看到一些不错的模式 <strong>演变</strong> 出来。</p>
<p>In order to understand these patterns you need a basic understanding of the <strong>React</strong> concepts and its ecosystem. Please note, however, that I will not cover them in this article.</p>
<p>为了理解这些模式，你需要对 React 的概念及其生态系统有一个基本的了解。请注意，我不会在这篇文章中介绍它们。</p>
<p>So let’s begin!</p>
<h2 id="Conditional-Render（条件渲染）"><a href="#Conditional-Render（条件渲染）" class="headerlink" title="Conditional Render（条件渲染）"></a>Conditional Render（条件渲染）</h2><p>I’ve seen the following scenario in a lot of projects.</p>
<p>我在很多项目都看到过以下场景。</p>
<p>When people think of <strong>React</strong> and <strong>JSX</strong>, they still think in terms of <strong>HTML</strong> and <strong>JavaScript</strong>.</p>
<p>当人们想到 <strong>React</strong> 和 <strong>JSX</strong> 时，他们心里仍然把它们当做 <strong>HTML</strong> 和 <strong>JavaScript</strong>。</p>
<p>So the natural step is to <strong>separate</strong> the conditional logic from the actual return code.</p>
<p>所以自然而然的，会把条件逻辑与实际的返回代码 <strong>分开</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> condition = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> innerContent = condition ? (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Show me<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  ) : <span class="literal">null</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is always visible<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">      &#123; innerContent &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>This tends to get out of control, with multiple <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="external">ternaries</a> at the beginning of each <code>render</code> function. You constantly have to jump inside the function to understand when a certain element is rendered or not.</p>
<p>在每个 <code>render</code> 函数的开始处有多个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="external">三元运算符</a>，这往往会失去控制。你必须不断地跳到函数内部来理解某个元素何时被渲染。</p>
<p>As an alternative, try the following pattern, where you benefit from the execution model of the language.</p>
<p>相反，可以尝试以下模式替代，从语言的执行模型中受益。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> condition = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is always visible<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    &#123;</div><div class="line">      condition &amp;&amp; (</div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Show me<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p>If <code>condition</code> is false, the second operand of the <code>&amp;&amp;</code> operator is not evaluated. If it is true, the second operand —<strong>or the JSX we wish to render</strong> is returned.</p>
<p>如果 <code>condition</code> 为 false，则 <code>&amp;&amp;</code> 运算符的第二个操作数不会被运算。如果它为 true，则返回第二个操作数或我们想要呈现的JSX。</p>
<p>This allows us to <strong>mix</strong> UI logic with the actual UI elements in a <strong>declarative</strong> way!</p>
<p>这使我们能够以 <strong>声明</strong> 的方式将 UI 逻辑与实际的 UI 元素 <strong>混合</strong> 在一起！</p>
<p>Treat JSX like it’s an integral part of your code! After all, it’s just <strong>JavaScript</strong>.</p>
<p>将 JSX 视为代码的一部分！毕竟，它就是 JavaScript。</p>
<h2 id="Passing-Down-Props（向下传递-Props）"><a href="#Passing-Down-Props（向下传递-Props）" class="headerlink" title="Passing Down Props（向下传递 Props）"></a>Passing Down Props（向下传递 Props）</h2><p>When your application grows, you have smaller components that act as containers for other components.</p>
<p>当你的应用程序增长时，会有更小的组件作为其他组件的容器。</p>
<p>As this happens, you need to pass down a good chunk of props through a component. The component doesn’t need them, but its children do.</p>
<p>这时，你需要通过组件传递大量 props。该组件不需要它们，但它的子组件可能需要。</p>
<p>A good way of bypassing this is to use <strong>props destructuring</strong> together with <strong>JSX spread</strong>, as you can see here:</p>
<p>一个好的绕过它方法就是对传递给 JSX 的属性使用 <strong>属性解构</strong>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> Details = <span class="function">(<span class="params"> &#123; name, language &#125; </span>) =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123; name &#125; works with &#123; language &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">const</span> Layout = <span class="function">(<span class="params"> &#123; title, ...props &#125; </span>) =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h1&gt;&#123; title &#125;&lt;/h1&gt;</div><div class="line">    &lt;Details &#123; ...props &#125; /&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div><div class="line"></div><div class="line">const App = () =&gt; (</div><div class="line">  &lt;Layout</div><div class="line">    title="I'm here to stay"</div><div class="line">    language="JavaScript"</div><div class="line">    name="Alex"</div><div class="line">  /&gt;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>So now, you can change the props needed for <code>Details</code> and be sure that those props are not referenced in multiple components.</p>
<p>所以现在，你可以改变 <code>Details</code> 所需要的 Props ，并确保那些 props 没有在其他组件中被多余的引用。</p>
<h2 id="Destructuring-Props（解构-Props）"><a href="#Destructuring-Props（解构-Props）" class="headerlink" title="Destructuring Props（解构 Props）"></a>Destructuring Props（解构 Props）</h2><p>An app changes over time, and so do your components. A component you wrote two years ago might be stateful, but now it can be transformed into a stateless one. The other way around also happens a lot of times!</p>
<p>随着时间的推移，你的应用程序和组件也会变化。你两年前写的一个组件可能是有状态的，但现在它可以转化为无状态组件。反之，也会发生！</p>
<p>Since we talked about props destructuring, here’s a good trick I use to make my life easier on the long run. You can destructure your props in a similar manner for both types of components, as you can see below:</p>
<p>之前，我们讨论了属性解构，从长远来看，这是一个让我的生活更轻松的好方法。你可以按照类似的方式为两种不同类型的组件解构属性，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> Details = <span class="function">(<span class="params"> &#123; name, language &#125; </span>) =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123; name &#125; works with &#123; language &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Details</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; name, language &#125; = <span class="keyword">this</span>.props;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123; name &#125; works with &#123; language &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Notice that lines <code>2–4</code> and <code>11–13</code> are <strong>identical.</strong> Transforming components is much easier using this pattern. Also, you limit the usage of <code>this</code> inside the component.</p>
<p>注意第 <code>2-4</code> 行和第 <code>11-13</code> 行是 <strong>等价</strong> 的。使用这种模式可以更轻松地转换组件。此外，还可以限制组件内部 <code>this</code> 的使用。</p>
<h2 id="Provider-Pattern-Provider-模式"><a href="#Provider-Pattern-Provider-模式" class="headerlink" title="Provider Pattern(Provider 模式)"></a>Provider Pattern(Provider 模式)</h2><p>We looked at an example where props need to be sent down through another component. But what if you have to send it down 15 components?</p>
<p>前面，我们看了一个例子，Props 需要通过另一个组件传递。但是如果你不得不将它传递给 15 个组件呢？</p>
<p>Enter <a href="https://reactjs.org/docs/context.html" target="_blank" rel="external">React Context</a>!</p>
<p>This is not necessarily the most recommended feature of React, but it gets the job done when needed.</p>
<p>查看 <a href="https://reactjs.org/docs/context.html" target="_blank" rel="external">React Context</a>！这不一定是 React 最推荐的功能，但它可以在需要时完成工作。</p>
<p>It was <a href="https://twitter.com/acdlite/status/956390180637650944" target="_blank" rel="external">recently announced</a> that the Context is getting a new API, which implements the <strong>provider pattern</strong> out of the box.</p>
<p>最近 <a href="https://twitter.com/acdlite/status/956390180637650944" target="_blank" rel="external">React 宣布</a> Context 正在更新一个新的 API，它实现了开箱即用的 <strong>provider 模式</strong>。</p>
<p>If you are using things like <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">React Redux</a> or <a href="https://github.com/apollographql/react-apollo" target="_blank" rel="external">Apollo</a>, you might be familiar with the pattern.</p>
<p>如果你正在使用的 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">React Redux</a> 或 <a href="https://github.com/apollographql/react-apollo" target="_blank" rel="external">Apollo</a>，你可能会非常熟悉这种模式。</p>
<p>Seeing how it works with today’s API will help you understand the new API as well. You can play around with the following sandbox.</p>
<p>我们来看看它如何与现有的 API 协同工作，这将有助于你理解新的 Context API。你可以在 <a href="https://codesandbox.io/s/rww6k3mq94?from-embed" target="_blank" rel="external">sandbox</a> 中运行它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MousePositionProvider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.state = &#123; &#125;;</div><div class="line">    <span class="keyword">this</span>.onMouseMove = <span class="keyword">this</span>.onMouseMove.bind( <span class="keyword">this</span> );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getChildContext() &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">posX</span>: <span class="keyword">this</span>.state.posX,</div><div class="line">      <span class="attr">posY</span>: <span class="keyword">this</span>.state.posY</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener( <span class="string">"mousemove"</span>, <span class="keyword">this</span>.onMouseMove );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  onMouseMove( e ) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">posX</span>: e.clientX, <span class="attr">posY</span>: e.clientY &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MousePositionProvider.childContextTypes = &#123;</div><div class="line">  <span class="attr">posX</span>: PropTypes.number,</div><div class="line">  <span class="attr">posY</span>: PropTypes.number</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MousePositionConsumer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Your position is ( &#123;this.context.posX&#125;,&#123;this.context.posY&#125; )<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MousePositionConsumer.contextTypes = &#123;</div><div class="line">  <span class="attr">posX</span>: PropTypes.number,</div><div class="line">  <span class="attr">posY</span>: PropTypes.number</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">MousePositionProvider</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">MousePositionConsumer</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">MousePositionConsumer</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">MousePositionProvider</span>&gt;</span></div><div class="line">);</div><div class="line"></div><div class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'));</span></div></pre></td></tr></table></figure>
<p>The top level component——called <strong>Provider</strong>——sets some values on the context. The child components——called <strong>Consumers</strong>——will grab those values from the context.</p>
<p>顶级组件（<code>Provider</code>），在 <code>Context</code> 中设置了一些值。子组件（<code>Consumers</code>），从 <code>Context</code> 中获取这些值。</p>
<p>The current context syntax is a bit strange, but the upcoming version is implementing this exact pattern.</p>
<p>目前的 <code>Context</code> 的语法有点奇怪，但即将推出的新版本正在按照这种模式实现。</p>
<h2 id="High-Order-Components（高阶组件）"><a href="#High-Order-Components（高阶组件）" class="headerlink" title="High Order Components（高阶组件）"></a>High Order Components（高阶组件）</h2><p>Let’s talk about reusability. Together with dropping the old <code>React.createElement()</code> factory, the React team also dropped the support for <a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="external">mixins</a>. They were, at some point, the standard way of composing components through plain object composition.</p>
<p>我们来谈谈可重用性。像被丢弃的旧的 <code>React.createElement()</code> 工厂方法一样，React 团队也放弃了对 <a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="external">mixins</a> 的支持。在某种程度上来说，复合组件的标准方式是通过简单对象的组合。</p>
<p><a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="external">High Order Components</a>—HOCs from now on—went out to fill the need for reusing behavior across multiple components.</p>
<p><a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="external">高阶组件</a> - 现在开始的 HOC - 能够满足跨多个组件重用行为的需求。</p>
<p>A HOC is a function that takes an input component and returns an <strong>enhanced/modified</strong> version of that component. You will find HOCs under different names, but I like to think of them as <strong>decorators</strong>.</p>
<p>HOC 是一个接收输入组件并返回该组件的 <strong>增强或修改</strong> 版本的函数。你会发现 HOC 有不同的名称，但我喜欢把它们看作 <strong>装饰器</strong>。</p>
<p>If you are using Redux, you will recognize that the <code>connect</code> function is a HOC—takes your component and adds a bunch of <code>props</code> to it.</p>
<p>如果你使用 <code>Redux</code>，你会发现 <code>connect</code> 函数就是一个 HOC –接收你的组件，并为它添加一堆 <code>Props</code>。</p>
<p>Let’s implement a basic HOC that can add props to existing components.</p>
<p>我们来实现一个基本的 HOC，它可以为现有的组件添加额外的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> withProps = <span class="function">(<span class="params"> newProps </span>) =&gt;</span> ( WrappedComponent ) =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> ModifiedComponent = <span class="function">(<span class="params"> ownProps </span>) =&gt;</span> ( <span class="comment">// the modified version of the component</span></div><div class="line">    &lt;WrappedComponent &#123; ...ownProps &#125; &#123; ...newProps &#125; /&gt; <span class="comment">// original props + new props</span></div><div class="line">  );</div><div class="line"></div><div class="line">  <span class="keyword">return</span> ModifiedComponent;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Details = <span class="function">(<span class="params"> &#123; name, title, language &#125; </span>) =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123; title &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123; name &#125; works with &#123; language &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">const</span> newProps = &#123; <span class="attr">name</span>: <span class="string">"Alex"</span> &#125;; <span class="comment">// this is added by the hoc</span></div><div class="line"><span class="keyword">const</span> ModifiedDetails = withProps( newProps )( Details ); <span class="comment">// hoc is curried for readability</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">ModifiedDetails</span></span></span></div><div class="line">    <span class="attr">title</span>=<span class="string">"I'm here to stay"</span></div><div class="line">    <span class="attr">language</span>=<span class="string">"JavaScript"</span></div><div class="line">  /&gt;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>If you like functional programming, you will love working with high order components. <a href="https://github.com/acdlite/recompose" target="_blank" rel="external">Recompose</a> is a great package that gives you all these nice utility HOCs like <code>withProps</code>, <code>withContext</code>, <code>lifecycle</code>, and so on.</p>
<p>如果你喜欢函数式编程，你将会喜欢使用高阶组件。<a href="https://github.com/acdlite/recompose" target="_blank" rel="external">Recompose</a> 是一个很好的软件包，可以为你提供所有这些好用的HOC，例如<code>withProps</code>, <code>withContext</code>, <code>lifecycle</code> 等等。</p>
<p>Let’s have a look at a very useful example of <strong>reusing functionality</strong>.</p>
<p>让我们来看一个很有用的 <strong>功能复用</strong> 的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withAuthentication</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> ModifiedComponent = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!props.isAuthenticated) &#123;</div><div class="line">      <span class="keyword">return</span> &lt;Redirect to="/login" /&gt;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return (&lt;WrappedComponent &#123; ...props &#125; /&gt;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  const mapStateToProps = (state) =&gt; (&#123;</div><div class="line">    isAuthenticated: state.session.isAuthenticated</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  return connect(mapStateToProps)(ModifiedComponent);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>You can use <code>withAuthentication</code> when you want to render sensitive content inside a route. That content will only be available to logged-in users.</p>
<p>当你想要在一个路由内展示敏感的内容时，你可以使用 <code>withAuthentication</code> ，该内容将只对登录的用户可用。</p>
<p>This is a <a href="https://en.wikipedia.org/wiki/Cross-cutting_concern" target="_blank" rel="external">cross-cutting concern</a> of your application implemented in a single place and reusable across the entire app.</p>
<p>这是一个<a href="https://en.wikipedia.org/wiki/Cross-cutting_concern" target="_blank" rel="external">cross-cutting concern</a>，实现一次，并可以整个应用程序中重用。</p>
<p>However, there is a downside to HOCs. Each HOC will introduce an additional React Component in your DOM/vDOM structure. This can lead to potential performance problems as your application scales.</p>
<p>但是，HOC 有一个缺点。每个 HOC 将在你的 <code>DOM/vDOM</code> 结构中引入一个额外的 React 组件。随着应用程序的扩展，这可能会导致潜在的性能问题。</p>
<p>Some additional problems with HOCs are summarized in <a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" target="_blank" rel="external">this great article</a> by <a href="https://twitter.com/mjackson" target="_blank" rel="external">Michael Jackson</a>. He advocates replacing HOCs with the pattern we’ll be talking about next.</p>
<p><a href="https://twitter.com/mjackson" target="_blank" rel="external">Michael Jackson</a> 在<a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" target="_blank" rel="external">这篇不错的文章</a>中总结了 HOC 的一些其他问题，他主张用我们接下来要讨论的模式来取代 HOC。</p>
<h2 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h2><p>While it is true that <strong>render props</strong> and <strong>HOCs</strong> are interchangeable, I don’t favor one over another. Both patterns are used to improve reusability and code clarity.</p>
<p>尽管 <strong>render props</strong> 和 <strong>HOCs</strong> 是可以互换的，但我并不赞成使用一个替换另一个，这两种模式都用于提高代码可复用性和清晰度。</p>
<p>The idea is that you <strong>yield</strong> the control of your render function to another component that then passes you back the control through a function prop.</p>
<p>这个想法是，你将渲染函数的控制权<strong>转让</strong>给另一个组件，然后另一个组件通过函数的 prop 传回给你。</p>
<p>Some people prefer to use a <strong>dynamic prop</strong> for this, some just use <code>**this.props.children**</code>.</p>
<p>有些人只是使用 <code>**this.props.children**</code>，而有些人更喜欢使用<strong>动态的 prop</strong>。</p>
<p>I know, it’s still very confusing, but let’s see a simple example.</p>
<p>这样听起来仍然很混乱，我们来看一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollPosition</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">position</span>: <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">this</span>.updatePosition = <span class="keyword">this</span>.updatePosition.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener( <span class="string">"scroll"</span>, <span class="keyword">this</span>.updatePosition );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  updatePosition() &#123;</div><div class="line">    <span class="keyword">this</span>.setState( &#123; <span class="attr">position</span>: <span class="built_in">window</span>.pageYOffset &#125; )</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children( <span class="keyword">this</span>.state.position )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">ScrollPosition</span>&gt;</span></div><div class="line">      &#123; ( position ) =&gt; (</div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>You are at &#123; position &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      ) &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">ScrollPosition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p>Here we are using <code>children</code> as the render prop. Inside the <code>&lt;ScrollPosition&gt;</code> component we will send a function which receives the <code>position</code> as a parameter.</p>
<p>我们在这里使用 <code>children</code> 作为渲染道具。在 <code>&lt;ScrollPosition&gt;</code> 组件中，我们将传递一个接收 <code>position</code> 作为参数的函数。</p>
<p>Render props can be used in situations where you need some reusable logic <strong>inside</strong> the component and you don’t want to wrap your component in a HOC.</p>
<p>渲染道具可用于在组件<strong>内部</strong>需要一些可重用逻辑，并且你不希望将组件包装在 HOC 中的情况。</p>
<p><a href="https://github.com/chenglou/react-motion" target="_blank" rel="external">React-Motion</a> is one of the libraries that offer some great examples of using render props.</p>
<p><a href="https://github.com/chenglou/react-motion" target="_blank" rel="external">React-Motion</a>是一个提供了很好的使用了  <strong>render props</strong> 例子的库。</p>
<p>Finally, let’s look at how we can integrate <strong>async</strong> flows with render props. Here’s a nice example of creating a reusable <code>Fetch</code> component.</p>
<p>最后，我们来看看我们如何将 <strong>异步</strong> 流程与 <strong>render props</strong> 进行整合。这是一个很好的创建可重用的 <code>Fetch</code> 组件的例子。</p>
<p>I’m sharing a sandbox link so you can play with it and see the results.</p>
<p>我分享一个 sandbox 链接，以便你可以使用它并查看运行结果。</p>
<p><a href="https://codesandbox.io/s/myv3nywvp?from-embed" target="_blank" rel="external">点击查看可运行示例</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetch</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">content</span>: <span class="string">""</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">content</span>: <span class="keyword">this</span>.props.loading() &#125;)</div><div class="line">    fetch(<span class="keyword">this</span>.props.url)</div><div class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">      .then(</div><div class="line">        <span class="function"><span class="params">res</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">content</span>: <span class="keyword">this</span>.props.done(res) &#125;),</div><div class="line">        res =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">content</span>: <span class="keyword">this</span>.props.error() &#125;)</div><div class="line">      )</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.state.content;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Fetch</span></span></span></div><div class="line">    <span class="attr">url</span>=<span class="string">"https://www.booknomads.com/api/v0/isbn/9789029538237"</span></div><div class="line">    <span class="attr">loading</span>=<span class="string">&#123;()</span> =&gt; (</div><div class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading ... <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )&#125;</div><div class="line">    done=&#123;(book) =&gt; (</div><div class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>You asked for: &#123; book.Authors[0].Name &#125; - &#123;book.Title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )&#125;</div><div class="line">    error=&#123;() =&gt; (</div><div class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Error fetching content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )&#125;</div><div class="line">  /&gt;</div><div class="line">);</div><div class="line"></div><div class="line">render(<span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'));</div></pre></td></tr></table></figure>
<p>You can have <strong>multiple</strong> render props for the same component. With this pattern, you have endless possibilities of composing and reusing functionality.</p>
<p>你可以为同一个组件提供<strong>多个</strong>可渲染的 props。有了这种模式，你可以无限制地编写和重用功能。</p>
<p>What patterns do you use? Which of them would fit in this article? Drop me a message bellow or write your thoughts on <a href="https://twitter.com/alexnmoldovan" target="_blank" rel="external">Twitter</a>.</p>
<p>你使用过什么样的模式？有哪一个适合这篇文章？给我发一封消息，或在 <a href="https://twitter.com/alexnmoldovan" target="_blank" rel="external">Twitter</a> 上写下你的想法。</p>
<p>If you found this article useful, help me share it with the community!</p>

        </div>
        
<footer class="article-footer">
  <div class="cc">
    <a class="cc-images" rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
      <img alt="知识共享许可协议" style="border-width:0" src="https://creativecommons.org/wp-content/themes/creativecommons.org/images/chooser_cc.png" />
      <img alt="知识共享许可协议" style="border-width:0" src="https://creativecommons.org/wp-content/themes/creativecommons.org/images/chooser_by.png" />
      <img alt="知识共享许可协议" style="border-width:0" src="https://creativecommons.org/wp-content/themes/creativecommons.org/images/chooser_nc.png" />
    </a>
    <span class="cc-text"> 本网站<strong>原创内容（非转载文章）</strong>采用 
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
        知识共享署名-非商业性使用 4.0 国际许可协议</a>
      进行许可。
    </span>
  </div>

  

    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more">分享到：</a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间">QQ空间</a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博">新浪微博</a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信">微信</a>
</div>
<script>
window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{"bdSize":16} };with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script>
<style>
    .bdshare_popup_box {
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .bdshare-button-style0-16 a,
    .bdshare-button-style0-16 .bds_more {
        padding-left: 20px;
        margin: 6px 10px 6px 0;
    }
    .bdshare_dialog_list a,
    .bdshare_popup_list a,
    .bdshare_popup_bottom a {
        font-family: 'Microsoft Yahei';
    }
    .bdshare_popup_top {
        display: none;
    }
    .bdshare_popup_bottom {
        height: auto;
        padding: 5px;
    }
</style>



</footer>
    </div>
</article>

    <section id="comments">
    
        
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!--  
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
-->
<div id="comment-container"></div>
<script>
  $(function() {
    setTimeout(function() {
      var gitalk = new Gitalk({
        clientID: '010a558ff67c828f318a',
        clientSecret: '08a6f4955996cb3d6ecb5fdfb4d564a9297a264b',
        repo: 'tcatche.github.io.comments',
        owner: 'tcatche',
        admin: ['tcatche'],
        id: location.pathname.substr(0, 50),      // Ensure uniqueness and length less than 50
        distractionFreeMode: true,
        perPage: 30
      });
      gitalk.render('comment-container');
  
      // var gitment = new Gitment({
      //   id: location.pathname, // 可选。默认为 location.href
      //   owner: 'tcatche',
      //   repo: 'tcatche.github.io.comments',
      //   oauth: {
      //     client_id: '010a558ff67c828f318a',
      //     client_secret: '08a6f4955996cb3d6ecb5fdfb4d564a9297a264b',
      //   },
      // })
      // gitment.render('comment-container');
    }, 100)
  })
</script>
    
    </section>


        </div>
      </section>
      
    </div>
  </div>
  <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2019 tcatche</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. </p>
                <p>Theme based <a href="//github.com/ppoffice" target="_blank">PPOffice</a> and modify by Tcatche. </p>
                <p>Hosted by <a  href="https://pages.github.com/">Github Pages</a>. </p>
            </div>
        </div>
    </div>
</footer>
  <div id="fixed">
  <i class="fa fa-search ins-search-icon" name="search"></i>
  <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-image-wrapper"></div>
        <div class="ins-bookmark-wrapper">
            <div class="ins-bookmark-container"></div>
        </div>
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
        <div class="ins-search-close">&times;</div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>
  <i id="back-to-top" class="fa fa-arrow-up goto-top" name="goto top"></i>
</div>
  


    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    


<!-- Custom Scripts -->
<script src="/js/main.js"></script>

</body>
</html>
